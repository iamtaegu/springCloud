# springCloud
스프링 클라우드 코딩 공작소 (2판)

## 마이크로서비스 애플레케이션 구축 기술 
 * 스프링 클라우드
 * 스프링 부트
 * 스웨거
 * 도커
	* 지속적으로 출시하고 통합할 수 있는 자체 빌드 및 배포 파이프라인 구축 
 * 쿠버네티스
 * ELK 스택
 * 그라파나
 * 프로메테우스
 
## 스프링 부트 
 * 스프링 프레임워크를 재구성한 것인데
 * 스프링의 핵심 기능은 수용하고, 불필요한 엔터프라이즈 제품은 걷어냈음
 * 자바 기반의 REST 지향 프레임워크를 제공하며
 * 애너테이션 기반으로 패키징하고 배포할 수 있는 REST 서비스를 신속히 만들 수 있게 함 

## EC2 
 * newgrp docker
 
## 도커
 * aws 2022-webservice에 설치
 
## ELK

 * 서비스 기동 시 bootstrap.yml > config.uri를 인식 못하고
    * 파일 분리
    * docker-compose-0 > 1 > 2 > docker-compoe.yml (default) 순서

## chapter9

 * 키클록은 다양한 데이터베이스와 함께 사용할 수 있고, 예제는 임베디드 H2 데이터베이스를 사용 
 * 작업 내용
   1. 키클록 서비스에서 사용할 spmia-realm 생성
   2. 클라이언트 애플리케이션 등록
      * 클라이언트는 사용자 인증을 요청할 수 있는 개체
      * 클라이언트는 SSO 솔루션으로 보호하려는 애플리케이션인 경우임 
   3. realm roles(영역 역할) 생성
      * 선택적 단계로 각 사용자에 대한 역할을 더 잘 통제할 수 있음
      * 이러한 역할을 생성하지 않으려면 사용자를 직접 생성하면 됨 
   4. 사용자 구성
      * Users 메뉴에서 사용자 이름을 입력하고, 사용자 및 이메일 확인 옵션을 활성화
 * 액세스 토큰을 획득하려는 사용자 시뮬레이션
   1. 키클록 토큰 엔드포인트에 POST 호출할 때 애플리케이션, 시크릿 키, 사용자 ID와 패스워드를 전달

 * Keycloak을 사용하면서 개인정보를 처리할 수 있는 방법
   1. JWT 및 Redis 기반 세션 관리
   2. KeyCloak Token Exchange 및 사용자 정보 조회
   3. API 게이트웨이에서 사용자 정보 캐싱

 * 키클록 서버 접속을 위한 서비스 구성
   * 서비스를 보호 자원으로 설정하면 호출자는 이 서비스를 호출할 때마다 
     * 해당 서비스에 대한 베어러(Bearer) 토큰이 있는 인증 HTTP 헤더를 포함해야 함
   * 호출받은 보호 자원을 키클록 서버를 다시 호출해서 토큰이 유효한지 확인해야 함 

 * 키클록 사용자 인증 
   * 액세스 토큰을 획드하려는 사용자 시뮬레이션
     1. 사용자 인증 토큰을 획드하기 위해 애플리케이션 이름과 시크릿 키를 기본 인증 방법으로 전달
        * CLIENT_APPLICATION_NAME, SECRET / basic authentication
     2. Client 인증 정보를 설정하고, 사용자 인증 정보를 등록
        * HTTP form 양식으로 매개변수 전달
        * <b>사용자 데이터를 동기화</b>
            1. <b>사용자 데이터 마이그레이션</b>
            2. <b>사용자 데이터베이스 연동</b>

   * 액세스 토큰 응답 JSON 페이로드 다섯 가지 속성
     1. access_token: 보호 자원에 대한 액세스 토큰
     2. token_type: 인가 명세에 따라 다양한 토큰 타입을 정의할 수 있음
     3. refresh_token: 토큰 재발급 리프레시 토큰
     4. expires_in: 액세스 토큰 만료되기까지 걸리는 시간
     5. scope: 토큰 유효 범위
   
 * 키클록으로 마이크로 서비스 보호하기
    * 키클록 서버에 클라이언트 등록하고 역할과 함께 사용자 계정을 설정했다면 
    * 스프링 시큐리티와 키클록 스프링 부트 어댑터로 보호 자원 설정할 수 있음
      1. 보호할 마이크로서비스에 라이브러리를 추가하고
      2. 키클록 서버에 접속하도록 서비스 구성 정보를 설정하고
      3. 서비스에 액세스할 수 있는 대상과 사용자를 정의 

 * 액세스 토큰 보안 조치
   * HttpOnly & Secure Cookies

## chapter10

 * 분산 캐싱
   * 레디스는 크고 분산된 인메모리 해시맵과 같은 역할을 하는 키-값 데이터 저장소
     * 키와 함께 데이터를 저장하고 조회
   * 캐시와 통신할 때는 예외 처리에 주의를 기울여야 함
     * 회복력을 높이려고 레디스와 통신할 수 없을 때도 전체 호출이 실패하면 안 되므로,
       * 대신 예외를 기록하고 마이크로 서비스를 호출 
     * 예외 상황에서도 캐싱은 성능을 향상시키는 것이 목적이기 때문에 
       * 캐싱 서버가 없어도 호출을 수행하는 데 영향이 없어야 함 
 * 클라우드 캐싱과 메시징
   * 분산 캐시로 레디스를 사용하는 것은 클라우드에서 마이크로서비스 개발과 연관됨
     * 장점
       * 데이터 검색 성능 향상
         * 데이터베이스에서 읽어 오지 않고도 주요 서비스 성능을 향상
       * 데이터베이스 부하 감소
       * 주 데이터 저장소 또는 데이터베이스 성능 문제에 따른 회복력 상승 

 * 작업 내용 
   1. 스프링 데이터 레디스 의존성 추가
   2. 레디스 서버에 대한 데이터베이스 커넥션 설정 
   3. 코드에서 레디스 해시와 상호 작용하는 데 사용될 스프링 데이터 레디스 저장소 정의
      * OrganizationRedisRepository
   4. 레디스와 서비스가 레디스 데이터를 저장하고 읽어 오게 작성
      * OrganizationRestTemplateClietn
